# c_lib_lstring [lstring]
通过内存池句柄释放的 C 语言字符串极简实现

```
[2022 开始使用 github.dev 进行维护]
```

* C++ 用久了会觉得好累,还是 C 单纯明了. 但纯 C 最大的问题的内存释放,每次都要 free 实在不烦其烦. 而且纯 C 又没有函数退出时自动调用析构函数的机制,所以一直也没转到纯 C 上来. 一日在写 delphi 程序的时候忽然想起 delphi 的窗体释放也是自动的啊,仅仅多加一个父级窗体的句柄就能完成了. OK. 把这个父级释放子控件的思想换到 C 的内容释放上来,一切都顺风顺水了. 我后来听说 nginx 也有类似的内存池机制,也算英雄所见略同,当然了这两个英雄是 delphi 和nginx ,不是我. 
不过为了不引起太大的混乱,还要引入一下 php 源码对内存等资源的释放思想: 那就是所有内存在一次 php 脚本解析运行终了后全部统一释放.

* 有了这两种思想,写作中不再为内存烦恼了,实际工程中完成过 md5,des 等比较复杂的过程,抱着这两种思想为基础很容易的就实现了自释放的版本. 从此这个小小的lstring.c 文件就成为了我必不可少的工具. 因为工作环境的一再变迁 lstring 的版本有了不同的差异,所以我觉得还是放到 github 上来,以免自己都搞混乱了.
如果网友们要使用不要被它的源码吓倒,以后我会传些实现的调用例子上来,大家可以看到是很简单的.用过 delphi 的同学就更是觉得亲切了 :)

* 这个项目的核心文件只有两个 lstring.c 和 lstring_functions.c , 其中前者基本上不会再修改,后者也基本上是 C 函数的封装而已. 
* 另外因为本人写的程序网络应用为主,因此常用 socketplus.c 来在 windows 写测试客户端,所以有类似需求的同学们也可以看看.

--------------------------------------------------------
* 2022 分出了 2.0 版本

其实主要是增加了访问已释放或者未分配内存的检测，这在 C 语言里是最常见的错误。改动并不多，不过因为 ver1.0 已经在大量项目中成功应用了，备份一个独立的目录，以防万一。

新项目应该尽量使用 ver2.0

--------------------------------------------------------
* socketplus.c 

* 是我经常来写网络协议分析程序的简单库，非常方便简单。

简单示例

```C


if (0 == _socket_init_) {
	LoadFunctions_Socket();
	InitWinSocket();

	_socket_init_ = 1;
}

int so = CreateTcpClient();
ConnectHost(so, (char *)"www.test.com", 80);

std::string cmd;
cmd = "GET / HTTP/1.0\r\n\r\n";

SendBuf(so, (char *)cmd.data(), cmd.length());

std::vector<char> buf;
buf.resize(1024, 0);
// 填充整个vector为0
std::fill(buf.begin(), buf.end(), 0);

int r = Recv(so, buf.data(), buf.size());

```


